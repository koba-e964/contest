package main

import (
	"bufio"
	"fmt"
	"log"
	"os"
	"path"
	"path/filepath"
	"strings"
)

func isSolutionFileName(name string) bool {
	names := strings.Split(name, ".")
	// Executable files
	if len(names) == 1 {
		return false
	}
	// Temporary files generated by flycheck
	if strings.Contains(names[0], "flycheck") {
		return false
	}
	// Files for testing
	if strings.Contains(names[0], "test") {
		return false
	}
	// Alternative solutions
	if strings.Contains(names[0], "-") {
		return false
	}
	return true
}

func main() {
	exec, err := os.Executable()
	if err != nil {
		log.Fatal(err)
	}
	scriptDir := path.Dir(exec)
	// ABC
	matches, err := filepath.Glob(path.Join(scriptDir, "abc*"))
	if err != nil {
		log.Fatal(err)
	}
	numContests := 0
	numSolved := 0
	numUnsolved := 0
	for _, match := range matches {
		seen := map[string]bool{}
		remain := map[string]bool{}
		filepath.Walk(match, func(path string, info os.FileInfo, err error) error {
			if info.IsDir() {
				return nil
			}
			if info.Name() == "remain.txt" {
				// 読む
				file, err := os.Open(path)
				if err != nil {
					log.Println(err)
					return err
				}
				defer file.Close()

				scanner := bufio.NewScanner(file)
				for scanner.Scan() {
					line := scanner.Text()
					tokens := strings.Split(line, " ")
					if len(tokens) > 0 {
						remain[tokens[0]] = false
					}
				}
			} else {
				names := strings.Split(info.Name(), ".")
				if isSolutionFileName(info.Name()) {
					seen[names[0]] = false
				}
			}
			return nil
		})
		numContests += 1
		for name := range seen {
			if ok, _ := remain[name]; !ok {
				numSolved += 1
			}
		}
		numUnsolved += len(remain)
	}
	fmt.Printf("ABC:\n")
	fmt.Printf("#Contests: %d\n", numContests)
	fmt.Printf("#Solved: %d\n", numSolved)
	fmt.Printf("#Unsolved: %d\n", numUnsolved)
}
